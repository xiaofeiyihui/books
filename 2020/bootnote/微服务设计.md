# 《微服务设计》读书笔记

作者：Sam Newman

### ◆ 前言

>本书的网站地址是：http://bit.ly/building-microservices

### 第一章 微服务

#### ◆ 1.1 什么是微服务

>微服务就是一些协同工作的小而自治的服务。
>
>1.1.1 很小，专注于做好一件事
>根据业务的边界来确定服务的边界，这样就很容易确定某个功能代码应该放在哪里。而且由于该服务专注于某个边界之内，因此可以很好地避免由于代码库过大衍生出的很多相关问题。
>
>1.1.2 自治性
>服务之间均通过网络调用进行通信，从而加强了服务之间的隔离性，避免紧耦合。

#### ◆ 1.2 主要好处

> **1.2.1 技术异构性**
> 在一个由多个服务相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。尝试使用一种适合所有场景的标准化技术，会使得所有的场景都无法得到很好的支持。
>
> **1.2.2 弹性**
> 如果系统中的一个组件不可用了，但并没有导致级联故障，那么系统的其他部分还可以正常运行。服务边界就是一个很显然的舱壁。微服务系统本身就能够很好地处理服务不可用和功能降级问题。
>
> **1.2.3 扩展**
> 如果使用较小的多个服务，则可以只对需要扩展的服务进行扩展，这样就可以把那些不需要扩展的服务运行在更小的、性能稍差的硬件上。
>
> **1.2.4 简化部署**
> 在微服务架构中，各个服务的部署是独立的，这样就可以更快地对特定部分的代码进行部署。如果真的出了问题，也只会影响一个服务，并且容易快速回滚，这也意味着客户可以更快地使用我们开发的新功能。
>
> **1.2.5 与组织结构相匹配**
> 微服务架构可以很好地将架构与组织结构相匹配，避免出现过大的代码库，从而获得理想的团队大小及生产力。服务的所有权也可以在团队之间迁移，从而避免异地团队的出现。
>
> **1.2.6 可组合性**
> 分布式系统和面向服务架构声称的主要好处是易于重用已有功能。而在微服务架构中，根据不同的目的，人们可以通过不同的方式使用同一个功能。
>
> **1.2.7 对可替代性的优化**
> 如果你在一个大中型组织工作，很可能接触过一些庞大而丑陋的遗留系统。这些系统无人敢碰，却对公司业务的运营至关重要。使用微服务架构的团队可以在需要时轻易地重写服务，或者删除不再使用的服务。

#### **1.3 面向服务的架构**

> SOA（Service-Oriented Architecture，面向服务的架构）是一种设计方法，其中包含多个服务，而服务之间通过配合最终会提供一系列功能。一个服务通常以独立的形式存在于操作系统进程中。服务之间通过网络调用，而非采用进程内调用的方式进行通信。

#### 1.4 其他分解技术

> 当你开始使用微服务时会发现，很多基于微服务的架构主要有两个优势：首先它具有较小的粒度，其次它能够在解决问题的方法上给予你更多的选择。那么其他的分解技术是否也有相应的好处呢？
> **共享库、模块**

### 第2章 演化式架构师

微服务给我们提供了很多选择，因此也需要我们做很多决定。比如应该使用多少种不同的技术，不同的团队是否应使用不同的编程规范，是应该合并多个服务还是把一个服务拆成多个。我们应该如何做决定呢？这些架构支持在频繁变换的环境下以更快的节奏进行变化，因此架构师这个角色也需要做相应的改变。

#### ◆ 2.1 不准确的比较

>架构师的一个重要职责是，确保团队有共同的技术愿景，以帮助我们向客户交付他们想要的系统

>事实上，我们要创造的东西从设计上来说就是要足够灵活，有很好的适应性，并且能够根据用户的需求进行演化。
>
>当我们把自己和工程师或者建筑师做比较时，很有可能会做出错误的决定。

#### 2.2 架构师的演化视角

> 架构师应该像城市规划师那样专注在大方向上，只在很有限的情况下参与到非常具体的细节实现中来。他们需要保证系统不但能够满足当前的需求，还能够应对将来的变化。而且他们还应该保证在这个系统上工作的开发人员要和使用这个系统的用户一样开心。

#### ◆ 2.3 分区

>作为架构师，不应该过多关注每个区域内发生的事情，而应该多关注区域之间的事情。这意味着我们应该考虑不同的服务之间如何交互，或者说保证我们能够对整个系统的健康状态进行监控。至于多大程度地介入区域内部事务，在不同的情况下则有所不同。很多组织采用微服务是为了使团队的自治性最大化.

#### **◆ 2.4 一个原则性的方法**

做系统设计方面的决定通常都是在做取舍，而在微服务架构中，你要做很多取舍！当选择一个数据存储技术时，你会选择不太熟悉但能够带来更好可伸缩性的技术吗？在系统中存在两种技术栈是否可接受？那三种呢？做某些决策所需要的信息很容易获取，这些还算是容易的。但是有些决策所需要的信息难以完全获取，那又该怎么办呢？

##### 2.4.1 战略目标

如果你是制定公司技术愿景的人，那么你可能需要花费更多的时间和组织内非技术的部分（通常他们被叫作业务部门）进行交互。

##### 2.4.2 原则

为了和更大的目标保持一致，我们会制定一些具体的规则，并称之为原则，它不是一成不变的。

##### 2.4.3 实践

我们通过相应的实践来保证原则能够得到实施，这些实践能够指导我们如何完成任务。通常这些实践是技术相关的，而且是比较底层的，所以任何一个开发人员都能够理解。这些实践包括代码规范、日志数据集中捕获或者HTTP/REST作为标准集成风格等。实践应该巩固原则。

##### 原则和实践的真实例子

![image-20200406214405022](C:\Users\MrLi\AppData\Roaming\Typora\typora-user-images\image-20200406214405022.png)

#### 2.5 要求的标准

> 在优化单个服务自治性的同时，也要兼顾全局。一种能帮助我们实现平衡的方法就是，清楚地定义出一个好服务应有的属性。
>
> **监控**
> 能够清晰地描绘出跨服务系统的健康状态非常关键。这必须在系统级别而非单个服务级别进行考虑。
>
> **接口**
> 选用少数几种明确的接口技术有助于新消费者的集成。
>
> **架构安全性**
> 必须保证每个服务都可以应对下游服务的错误请求。
> 返回码也应该遵守一定的规则。
>
> 对以下几种请求做不同的处理可以帮助系统及时失败，并且也很容易追溯问题：（1）正常并且被正确处理的请求；（2）错误请求，并且服务识别出了它是错误的，但什么也没做；（3）被访问的服务宕机了，所以无法判断请求是否正常。

#### 2.6 代码治理

> **范例**
> 编写文档是有用的。如果你有一些很好的实践希望别人采纳，那么给出一系列的代码范例会很有帮助。理想情况下，你提供的优秀范例应该来自真实项目，而不是专门实现的一个完美的例子。
> **裁剪服务代码模板**
> 让所有的开发人员很容易地遵守大部分的指导原则：一种可能的方式是，当开发人员想要实现一个新服务时，所有实现核心属性的那些代码都应该是现成的。

#### 2.7 技术债务

> 架构师的职责就是从更高的层次出发，理解如何做权衡。理解债务的层次及其对系统的影响非常重要。对于某些组织来说，架构师应该能够提供一些温和的指导，然后让团队自行决定如何偿还这些技术债务。而其他的组织就需要更加结构化的方式，比如维护一个债务列表，并且定期回顾。

#### 2.8 例外管理

> 有时候我们会决定针对某个规则破一次例，然后把它记录下来。如果这样的例外出现了很多次，就可以通过修改原则和实践的方式把我们的理解固化下来。

#### 2.9 集中治理和领导

> 作为一名架构师，你必须要在团队驶向类似鸭子池塘这样的地方时抓紧他们。还有一点要注意的是，即使你很清楚什么是对的，然后尝试去控制团队，也可能会破坏和团队的关系，并且会使团队感觉他们没有话语权。有时候按照一个你不同意的决定走下去反而是正确的，知道什么时候可以这么做，什么时候不要这么做是很困难的，但有时也很关键。

#### 2.10 建设团队

> 对于一个系统技术愿景的主要负责人来说，执行愿景不仅仅等同于做技术决定，和你一起工作的那些人自然会做这些决定。对于技术领导人来说，更重要的事情是帮助你的队友成长，帮助他们理解这个愿景，并保证他们可以积极地参与到愿景的实现和调整中来。

#### 2.11 小结

> **· 愿景**
> 确保在系统级有一个经过充分沟通的技术愿景，这个愿景应该可以帮助你满足客户和组织的需求。· 同理心理解你所做的决定对客户和同事带来的影响。
>
> **· 合作**
> 和尽量多的同事进行沟通，从而更好地对愿景进行定义、修订及执行。
>
> **· 适应性**
> 确保在你的客户和组织需要的时候调整技术愿景。
>
> **· 自治性**
> 在标准化和团队自治之间寻找一个正确的平衡点。
>
> **· 治理**
> 确保系统按照技术愿景的要求实现。
>
> 演进式架构师应该理解，成功要靠不断地取舍来实现。总会存在一些原因需要你改变工作的方式，但是具体做哪些改变就只能依赖于自己的经验了。而僵化地固守自己的想法无疑是最糟糕的做法。

### 第3章 如何建模服务

#### 什么样的服务是好服务

> **松耦合**
> 如果做到了服务之间的松耦合，那么修改一个服务就不需要修改另一个服务。使用微服务最重要的一点是，能够独立修改及部署单个服务而不需要修改系统的其他部分
>
> **高内聚**
> 我们希望把相关的行为聚集在一起，把不相关的行为放在别处。为什么呢？因为如果你要改变某个行为的话，最好能够只在一个地方进行修改，然后就可以尽快地发布
>
> 所以，找到问题域的边界就可以确保相关的行为能放在同一个地方，并且它们会和其他边界以尽量松耦合的形式进行通信。

限界上下文、业务功能、逐步划分上下文、技术边界

◆ 3.8 小结

>Vaughn Vernon的《实现领域驱动设计》

### 第4章 集成

#### 理想的集成技术

> 避免破坏性修改
>
> 保证APl的技术无关性
>
> 使你的服务易于消费方使用
>
> 隐藏内部实现细节

◆ 4.5 编排与协同

>编排（orchestration）的话，我们会依赖于某个中心大脑来指导并驱动整个流程，
>
>协同（choreography）的话，我们仅仅会告知系统中各个部分各自的职责，而把具体怎么做的细节留给它们自己
>
>编排方式的缺点是，客户服务作为中心控制点承担了太多职责，它会成为网状结构的中心枢纽及很多逻辑的起点。

![image-20200406222014938](C:\Users\MrLi\AppData\Roaming\Typora\typora-user-images\image-20200406222014938.png)

>针对请求/响应方式，可以考虑两种技术：RPC（Remote Procedure Call，远程过程调用）和REST（REpresentational State Transfer，表述性状态转移

#### 小结

> · 无论如何避免数据库集成
>
> · 理解REST和RPC之间的取舍，但总是使用REST作为请求/响应模式的起点
>
> · 相比编排，优先选择协同
>
> · 避免破坏性修改、理解Postel法则、使用容错性读取器
>
> · 将用户界面视为一个组合层

### 第5章 分解单块系统

#### 小结

> 通过寻找服务边界把系统分解开来，且这可以是一个增量的过程。在最开始就要养成及时寻找接缝的好习惯，从而减少分割服务的代价，这样才能够在未来遇到新需求时继续演化我们的系统

### 第6章 部署

首先，专注于保持服务能够独立于其他服务进行部署的能力，无论采用什么技术，请确保它能够提供这个能力。我倾向于一个服务一个代码库，对于每个微服务一个CI这件事情，我不仅仅是倾向，并且非常坚持，因为只有这样才能实现独立部署。

接下来，如果可能的话，将每个服务放到单独的主机/容器中。看看类似LXC或者Docker这样的替代技术，如何简化对多个服务的管理。但要记住的一点是，无论你采用什么技术，自动化的文化对一切管理来说都非常重要。自动化一切，如果你采用的技术不支持的话，就去选用一个新的技术吧！使用类似AWS这样的平台，能够在你进行自动化时提供大量的便利。确保你理解部署技术的选择会对开发人员有怎样的影响，并确保他们也能够感受到。创建工具对任何给定服务到不同环境的自助部署提供服务，是非常重要的事情，因为它对开发、测试和运维人员都能提供很大的帮助。

最后，如果你想要深入了解这些话题，我强烈推荐你读一读Jez Humble和David Farley的《持续交付》

### 第7章 测试

蓝绿部署：新老版本服务都在生产，新功能服务不引入流量，测试完后，再引入流量。
金丝雀部署：新老版本服务都在生产，新功能引入少量流量（直接生产流量或者负责生产请求），没问题后再完全切入生产流量

### 第8章 监控

#### 对每个服务而言:

> · 最低限度要跟踪请求响应时间。做好之后，可以开始跟踪错误率及应用程序级的指标。
>
> · 最低限度要跟踪所有下游服务的健康状态，包括下游调用的响应时间，最好能够跟踪错误率。一些像Hystrix这样的库，可以在这方面提供帮助。
>
> · 标准化如何收集指标以及存储指标。
>
> · 如果可能的话，以标准的格式将日志记录到一个标准的位置。如果每个服务各自使用不同的方式，聚合会非常痛苦！
>
> · 监控底层操作系统，这样你就可以跟踪流氓进程和进行容量规划。

#### 对系统而言:

> · 聚合CPU之类的主机层级的指标及应用程序级指标。
>
> · 确保你选用的指标存储工具可以在系统和服务级别做聚合，同时也允许你查看单台主机的情况。
>
> · 确保指标存储工具允许你维护数据足够长的时间，以了解你的系统的趋势。
>
> · 使用单个可查询工具来对日志进行聚合和存储。
>
> · 强烈考虑标准化关联标识的使用。
>
> · 了解什么样的情况需要行动，并根据这些信息构造相应的警报和仪表盘。
>
> · 调查对各种指标聚合方式做统一化的可能性，像Suro或Riemann这样的工具可能会对你有用。

### 第9章 安全

**黄金法则:**不要实现自己的加密算法。不要发明自己的安全协议。

### 第10章 康威定律和系统设计

>任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。

### 第11章 规模化微服务

> 功能降级
>
> 架构性安全措施
>
> 超时、断路器、舱壁、隔离
>
> 幂等
>
> 扩展：更强大的主机、拆分负载、分散风险、负载均衡
>
> 扩展数据库：
>
> 缓存：客户端、代理和服务器端缓存；HTTP缓存；
>
> 自动伸缩
>
> CAP定理
>
> 服务发现
>
> 动态服务注册：Zookeeper、Consul、Eureka
>
> 文档服务：swagger、HAL和HAL浏览器
>
> 自描述系统

◆ 11.16 小结

>优秀图书《Release It  》：在书里他分享了一系列关于系统故障的故事，以及一些处理它们的模式

### 第12章 总结

#### 微服务的原则

> 围绕业务概念建模
>
> 接受自动化文化
>
> 隐藏内部实现细节
>
>  让一切都去中心化
>
>  可独立部署
>
> 隔离失败
>
>  高度可观察