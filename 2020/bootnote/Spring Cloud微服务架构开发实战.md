## Spring Cloud微服务架构开发实战

董超 胡炽维

### ◆ 前言

>本书涉及的所有源代码文件都可以从https://github.com/cd826/springcloud-demo网站上下载

## 第1篇 微服务开发基础——Spring Boot框架及使用

### 第一章 为服务架构开发

#### ◆ 1.1 单体架构应用的困境

>一个典型的单体架构应用就是将一个应用中所有的功能都打包在一个WAR文件中，并部署在应用服务器（如Tomcat）中运行

>对于单体架构应用来说，随着业务的扩张，其开发、部署和运维都会越来越慢，越来越复杂，甚至在单体架构应用开发中敏捷模式都无法施展开。

#### ◆ 1.2 微服务架构

>微服务架构中的服务其实和之前模块化开发很相似，但服务是有明确服务边界的，所以更易于开发和管控，同时也更易于单独部署和扩展。

##### 1.2.1 如何定义微服务架构

>对于一个应用系统包含两部分的需求：第一部分是功能性需求，用于定义一个应用是用来做什么的，该应用系统用来达到什么目的；第二部分就是非功能性需求，包括了对应用系统的扩展性、灵活性，还有性能、运维、安全、测试、监控等需求，这种非功能性需求是用来保障业务系统能够正确、顺畅地运行。而对于微服务架构来说，则着重于后一种需求。

>总而言之，**微服务核心思路就是分而治之**。对于微服务中的服务可以这么理解：服务是一个可以独立运行、提供范围有限的功能（可以是业务功能，也有可能是非业务功能）的组件。

##### 1.2.2 微服务架构的优却点

> 优点：松耦合、独立、更高可用性和弹性、应对用户需求的多样性、抽象
>
> 缺点：可用性降低、处理分布式事务棘手、全能对象阻止业务拆分、学习难度曲线加大、组织架构变更

#### ◆ 1.3 微服务架构设计

>如何进行微服务架构设计呢？
>
>简单来说可分为下面三个步骤：第一步，把应用中关键的需求定义出来；第二步，识别出采用微服务架构时应用中所包含的所有服务；第三步，将第一步所定义出的关键需求作为架构需求的场景来描述服务之间如何进行协作。
>
>在识别应用中的服务时，应首先专注于业务，通过业务逻辑的视角可以快速有效地将核心微服务识别出来。
>
>切记，不可以一开始从技术的角度去拆分，否则由于业务之间的关联关系很有可能会将设计出来的微服务拉入“焦油坑”中。

##### 1.3.1 微服务粒度

>对于设计微服务来说，最好的方式是先专注于各个服务之间的交互，先把它们划分成粗颗粒度的服务，然后随着系统的升级和功能的提升，再将这些粗颗粒度的服务逐渐细化，形成更为合理的微服务粒度。
>
>微服务架构的设计一定是与时俱进的，因此我们也不可能在第一次设计时就设计出一个完美的架构体系

##### 1.3.2 微服务拆分原则

>1．单一职责原则单一职责原则（Single Responsibility Principle, SRP）：一个类应该有且只有一个变化的原因。
>
>对于微服务设计来说，如果一个微服务承担太多职责的话，也会导致微服务业务之间的耦合，为业务进行改变时埋下了不稳定因素。所以，单一职责原则同样也适用于微服务设计，

>2．共同封闭原则共同封闭原则（Common Closure Principle, CCP）：包中的所有的类对于同一种性质的变化应该是共同封闭的。一个变化若对一个封闭的包产生影响，则将对该包中的所有类产生影响，而对其他包则不造成任何影响。
>
>当需要修改某项业务时，我们需要将修改的范围限制在同一个包内，而不是遍布在很多包中。
>
>同样，通过使用共同封闭原则可以将那些在业务上联系紧密，由于同一个原因而改变的服务组织在一个微服务中。这样一方面我们可以减少微服务的数量，另外一方面当业务发生改变时我们只需要一个业务开发团队进行单独修改，只需要重新部署该服务即可，减少了不同微服务开发团队之间沟通成本。

##### 1.3.3 微服务自治原则

>在微服务治理中有一个重要的理念就是自治，自治范围并不只是代码和数据，还包含微服务的运行和维护管理，所以亚马逊的微服务有一个规则：你构建，你运行。
>
>而微服务中的分而治之理念，不但是指业务功能，也同时包含了对业务数据的管理。将业务数据管理进行私有化之后就进一步降低了业务之间的耦合度
>
>微服务架构中的数据自治是指每个微服务拥有其业务领域对象下的数据，只有该微服务可以对这些数据进行操作（包含读取与更改），而其他微服务只有通过该服务才能访问到这些数据，不能直接通过数据库进行沟通

##### 1.3.4 微服务交互原则

>我们可以使用以下原则作为微服务接口设计的准则。
>
>·使用REST协议：REST可以说在微服务互相调用之间起着非常重要的角色，强烈建议大家使用HTTP作为服务的调用协议，并在服务处理上使用HTTP标准动词（GET、PUT、POST和DELETE）。
>
>·使用URI表达：服务端点的URI应该能够清晰表达出我们所要解决的问题、提供的方法、相应资源信息及资源之间的关联关系。
>
>·使用JSON数据格式：JSON作为轻量级数据格式协议，及自带的序列化和反序列化机制，几乎已经成为通信中的数据标准协议，并且对于前端开发来说非常容易使用与整合。
>
>·使用HTTP标准状态码：HTTP协议本身具有非常丰富的状态码，那么使用这些状态码来作为服务调用结果的状态是非常合适的。

##### 1.3.5 微服务架构迁移

>对于代码重构，有一个很重要的指导思想就是不要大规模进行重构，而是一小步一小步来。
>
>与大规模进行重构相反，在进行微服务架构迁移时可以使用Martin Fowler提出绞杀（Strangler）模式。

#### ◆ 1.4 不应使用微服务架构的情形

>当我们在开发时遇到下属情形时应避免使用微服务架构：
>·构建分布式架构非常吃力时；
>·服务器蔓延时；
>·采用小型应用、快速产品原型时；
>·对数据事务的一致性有一定要求时。

>微服务架构的诞生是为了解决可复用，并且需要快速扩展的大型应用的问题。但假如我们所要构建的应用比较小，功能简单，并且用户量也不是很大，或者我们所要构建的是初期产品，打算先开发出一个MVP，在这个基础上快速迭代找到用户真正关心的功能点，那么，采用微服务架构很显然在这个时候不适合，

>微服务架构只能满足CAP理论中的两点，

### 第2章 微服务基础——Spring Boot

#### ◆ 2.2 快速启动Spring Boot

>@SpringBootApplication注解告诉Spring容器：使用该类作为所有Bean源，通过该起始点构建应用的上下文。@SpringBootApplication注解继承自@EnableAutoConfiguration和@ComponentScan，通过该注解使得项目在启动时Spring就会对该类所属目录下的所有子包进行扫描并根据Spring Boot的自动配置机制进行配置。

>如果项目中由于某些原因不能这么做的话，可以通过@ComponentScan注解进行修正，在@ComponentScan注解中可以配置需要扫描包的位置

>假如在项目中所要扫描的包有多个，那么可以在注解中通过逗号（，）将这多个包路径分开，

>Application类的main()方法调用了SpringApplication.run()，该方法会在项目启动时构建一个Spring容器，并返回一个ApplicationContext对象，也就是项目应用的上下文。

>对于引导类来说其是整个应用启动的初始点，因此，如果在应用启动时需要进行某些初始化处理，那么最好都在该类中完成。

#### ◆ 2.3 使用Spring Boot构建示例项目

> 业务领域对象设计的更深层次的讨论，有兴趣的读者可以阅读《领域驱动设计：软件核心复杂性应对之道》

##### 1．关于Spring Data JPA

>·@Entity:对于该注解有一个需要注意的地方就是在该类中必须有一个空的构造函数。当从数据库中加载对象时，JPA就会通过该构造函数来实例化对象，并将数据库中的值赋值给所构建的示例，如果不小心在业务实体类中覆写了构造函数而忘记提供空的构造函数，就会造成数据加载错误。
>
>·@Id：用来注解数据库主键，并且通过@GeneratedValue告诉JPA自动生成主键的值

>为方便查询处理，Spring Data还提供了自然语义的数据访问处理机制。比如，我们可以在接口中定义一个名称为findTop10OrderByJoinDateDesc的方法，这时候Spring Data会自动实现查询最新加入的10个用户，并按照加入日期倒序排列。

>Spring Data还提供了@Query注解，可以直接在方法中声明该方法查询时所使用的查询语句，所声明的查询语句使用JPQL语言。

>如果我们所要处理的数据访问处理比这些还要复杂，很难通过声明一个JPQL语句实现，此时我们可以使用Spring Data的扩展机制，为Repository声明指定一个扩展接口并提供相应的实现类，

>需要注意的是，使用Ex只是一个默认约定，可以在项目中随便定义这个后缀，而实现类的Impl后缀是不可以随意定义的，但是可以在配置中通过repository-impl-postfix属性设置。

>当所继承的Repository中有些接口方法不需要时，那么可以在接口中重新声明需要的方法即可。

##### 2．关于H2

>对于H2数据库有两种使用方式：第一种是使用内存存储数据；第二种是使用文件存储数据。

##### 2.3.4 编写业务逻辑层

>按照开发方式来说，设计和开发的顺序应该是：Domian→REST API→业务逻辑层→数据存储层，通过测试驱动的方式设计所需要的功能

>数据传输对象（Data Transfer Object，简称DTO），用来处理跨进程或网络传输数据聚合容器。

>使用curl或Postman等工具直接访问所提供的RESTful API接口，验证功能的正确性。

>在使用@RestController时需要注意返回值，最好的方式就是对返回值进行统一包装，这样方便前端进行处理。

#### ◆ 2.4 Spring Boot特性

##### 2.4.1 Spring Boot自动配置机制

>Spring Boot自动配置机制从核心上可以总结为以下两点：
>·通过@EnableAutoConfiguration为基于Spring的应用开启自动配置机制；
>·通过一系列的@Conditional完成自动配置机制的实现。

>·@ConditionOnBean：在ApplicationContext中存在指定类型的Bean时启用。
>·@ConditionOnMissingBean：在ApplicationContext中不存在指定类型的Bean时启用。·@ConditionOnClass：在classpath下存在指定类时启用。
>·@ConditionOnMissingClass：在classpath下缺少指定类时启用。
>·@ConditionOnProperties：当存在指定属性配置时启用。
>·@ConditionOnResource：当存在指定资源时启用。
>·@ConditionOnWebApplication：当应用是一个Web应用时启用。

##### 2.4.2 Spring Boot扩展属性配置

>·@Value：将配置参数的值直接注入到指定的Bean属性中。
>
>> @Value可以使用SpEL表达式进行配置，同时还可以为该配置指定默认值（当属性配置文件中没有该属性配置时使用，这样可以避免在应用启动时报错）。
>
>·@ConfigurationProperties：通过指定的前缀，批量将配置的值注入一个Bean中。
>·Spring还提供了一些属性配置校验注解，如@NotNull、@Email、@Min、@Max等，可以辅助对参数配置进行有效性检验。

>在属性配置中，属性的名称并不需要与Bean中的字段名称严格保持一致。比如，在Bean中字段名称为wechatAppId，那么配置的属性名称可以为wechatAppId、wechat-app-id或WECHAT_APP_ID都是可以的.

##### 2.4.3 Spring Boot日志配置

>Spring Boot会使用自动配置机制，根据开发者所使用的日志系统对日志进行自动配置

>如果Spring Boot在class目录下发现了logback.xml（针对logback）或log4j.proerties（针对Log4j），那么Spring Boot就会启用这些配置。

#### ◆ 2.5 关于敏捷开发

>测试驱动开发（Test Driven Development，简称TDD

>测试驱动开发的一个最大优势就是在保障不改变功能的情况下可以持续地对代码进行改进和重构，这样就可以让开发者既能够快速开发又能够保障系统功能的稳定性。

>Controller层单元测试

>REST API就是多个团队之间的一种契约，而单元测试则可以监督契约的不可变性。

##### ◆ 2.6 关于RESTful API设计

>在进行RESTful API设计时，有以下指导原则可以参考：
>·以资源为中心进行URL设计；
>·正确使用HTTP方法及状态码；
>·查询及分页处理原则；
>·其他指导原则。

##### 2.6.1 以资源为中心进行URL设计

>根据RFC3986标准中规定，URL是大小写敏感的，而且Spring MVC默认对URL也是区分大小写的，所以为了避免歧义，定义URL时最好都使用小写字母。

>RESTful API的设计最好做到Hypermedia化，也就是在返回结果中包含所提供相关资源的链接，使得用户可以根据返回结果就能得到后续操作需要访问的地址

##### 2.6.2 正确使用HTTP方法及状态码

>GET用来获取资源，POST用来创建资源（也可以用于更新资源）, PUT用来更新资源，DELETE则是用来删除资源，还有一个PATCH方法用来更新资源，但用的比较少，常使用POST来替代。

>通常在创建或者更新一个资源时，应该返回资源的最新数据，而删除资源一般不会返回内容。

>由于REST是基于HTTP协议的，因此对于用户请求的应答中应该使用正确的状态码，以便客户端能够做出正确的处理。
>
>·2XX：请求正常处理并返回。
>·3XX：重定向，请求的资源位置发生变化。
>·4XX：客户端发送的请求有错误。
>·5XX：服务器端错误。
>
>可以参考网址https://httpstatuses.com/

##### 2.6.3 查询及分页处理原则

> 通常我们遇到查询时需要附加一些查询条件对所要显示的列表进行过滤，这个时候可以通过在URL中附加参数来实现，比如：
> ·?state=closed：查询指定状态。
> ·?limit=10：指定返回10条记录。
> ·?page=2& size=25&sort=created, desc：进行分页查询，并指定每页记录数及排序方式。

> 使用Spring Data的Pageable进行分页查询时，需要传入的分页参数的默认名称如下。
> ·page：所要查询的页面数，也就是第几页数据。从0开始，默认值也是0。
> ·size：每一页中最大记录数，默认值为20。
> ·sort：分页数据的排序字段及方式，格式为property(, ASC|DESC)。其中排序方式为可选，默认排序方式为升序（ASC）。该参数可以多个，比如sort=firstname&sort=lastname, asc。

##### 2.6.4 其他指导原则

>1．使用JSON作为响应返回格式

>2.API域名应该尽量将API全部部署在一个专用的域名之下，

>3.API版本在设计API时最好将API的版本放入URL中，如https://api.cd826dong/v1/users。

>4．错误处理当出现错误时，在响应的内容中需要通过errmsg给出明确的信息，还可以创建统一的错误码，可以使用errcode返回

## ◆ 第2篇 Spring Cloud组件实战

### 第3章 Spring Cloud简介

#### ◆ 3.1 微服务架构的核心关键点

>![image-20200421083739745](C:\Users\MrLi\AppData\Roaming\Typora\typora-user-images\image-20200421083739745.png)

#### ◆ 3.2 Spring Cloud技术概览

>Spring Cloud所提供的核心功能包含：
>·基于Netflix实现服务治理、客户端负载均衡和声明式调用；
>·服务网关；
>·微服务容错管理；
>·整合消息中间件提供消息驱动式开发；
>·基于Spring Security提供微服务安全、单点登录功能；
>·分布式、版本化的统一配置管理；
>·微服务调用链及追踪管理

##### Spring Cloud与服务治理

>Eureka提供了服务注册中心、服务发现客户端，以及注册服务的UI界面应用。在Eureka的实现中，节点之间相互平等，有部分注册中心“挂掉”也不会对整个应用造成影响，即使集群只剩一个节点存活，也可以正常地治理服务

##### Spring Cloud与客户端负载均衡

>Spring Cloud通过对Netflix微服务开源项目中的Ribbon再次封装，实现了客户端负载均衡。Ribbon默认与Eureak进行无缝整合，当客户端启动的时候，从Eureka服务器中获取一份服务注册列表并维护在本地，当服务消费者需要调用服务时，Ribbon就会根据负载均衡策略选择一个合适的服务提供者实例并进行访问。

##### Spring Cloud与微服务容错、降级

>Hystrix是根据“断路器”模式而创建。当Hystrix监控到某服务单元发生故障之后，就会进入服务熔断处理，并向调用方返回一个符合预期的服务降级处理（fallback），而不是长时间的等待或者抛出调用异常，从而保障服务调用方的线程不会被长时间、不必要地占用，避免故障在应用中的蔓延造成的雪崩效应。
>
>而Hystrix的仪表盘项目（Dashboard）可以监控各个服务调用所消耗的时间、请求数、成功率等，通过这种近乎实时的监控和告警，可以及时发现系统中潜在问题并进行处理。

##### Spring Cloud与服务网关

>Spring Cloud通过集成Netflix中的Zuul实现API服务网关功能，提供对请求的路由和过滤两个功能，其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础。过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。
>
>Zuul默认会与Eureka服务器进行整合，自动从Eureka服务器中获取所有注册的服务并进行路由映射，实现API服务网关自动配置。
>
>后续有推出了spring cloud gateway,

##### Spring Cloud与消息中间件

>Spring Cloud Bus基于Stream进行扩展，可以作为微服务之间的事件、消息总线，用于服务集群中状态变化的传播。

##### Spring Cloud与分布式配置中心

>Spring Cloud提供了一个Config子项目。SpringCloud Config具有中心化、版本控制、支持动态更新和语言独立等特性。在Config子项目中将微服务应用分为两种角色：配置服务器（Config Server）和配置客户端（Config Client）。

##### Spring Cloud与微服务链路追踪

>Spring Cloud中的Sleuth子项目为开发者提供了微服务之间调用的链路追踪。Sleuth核心思想就是通过一个全局的ID将分布在各微服务服务节点上的请求处理串联起来，还原了调用关系，并借助数据埋点，实现对微服务调用链路上的性能数据的采集。
>
>通过将采集的数据发送给Zipkin进行存储、统计和分析，从而可以实现可视化的分析和展示，帮助开发者对微服务实施优化处理。

##### Spring Cloud与微服务安全

>Spring Cloud Security为我们提供了一个认证和鉴权的安全框架，实现了资源授权、令牌管理等功能，同时结合Zuul可以将认证信息在微服务调用过程中直接传递，简化了我们进行安全管控的开发

##### Spring Cloud其他子项目

>·Spring Cloud Cli：提供了以命令行和脚本的方式来管理微服务。
>·Spring Cloud Data Flow：一个用于开发、执行大数据处理的统一编程模型和托管服务。其基于原生云，并重新对Spring XD进行设计，简化了大数据应用的开发，为基于微服务的分布式流处理和批处理数据通道提供了一系列模型和最佳实践。
>·Spring Cloud Task：用于短时的任务管理和调度微服务管理，通常与Data Flow一起使用。
>·Spring Cloud Starters：类似于Spring Boot的启动项目，为基于Spring Cloud的微服务开发提供开箱即用的依赖管理。
>·Spring Cloud Contract：这是面向Java的契约框架，消费者驱动的，旨在帮助开发者完成微服务测试的子项目。

##### 3.2.2 为何选择Spring Cloud

>·Spring Cloud作为Spring Boot的传承，遵循约定优于配置的原则，在使用时不需要复杂的配置就可以运行起来，学习曲线低。
>·Spring Cloud中的大部分子项目开箱即用，采用自动化配置机制，可说使用门槛非常低。
>·Spring Cloud属于Spring大家族，而Spring是进行企业级开发的首选框架，因此在项目中引入Spring Cloud的技术成本比较低。
>·Spring Cloud的口号就是开发“面向云环境的应用程序”，通过集成成熟的第三方开源组件，为微服务架构的开发提供了全方位的支持，并且在Spring这棵大树下后续的更新、完善都有保障。
>·Spring Cloud抛弃了传统的RPC通信，采用了基于HTTP的REST方式，使得微服务接口更为灵活，服务提供者和消费者之间的依赖只需要一纸契约即可，而不存在代码级别的强依赖，这对快速演化的微服务架构更合适。·Spring Cloud并没有限制所使用的环境，可以与异构系统进行整合。同时对于所提供的各组件服务既可单独部署，又可集中部署，方便了运维和管理。

>在@FeignClient注解中，value属性表示所要调用的具体服务名称HP-SERVICE，而fallback属性设置为HelloServiceFallback.class，表示当所调用的微服务不可用时，使用该类所提供功的能替代原服务，也就是微服务容错功能。
>
>当我们使用Feign时，就会默认与Spring Cloud所提供的客户端负载均衡Ribbon集成.

#### ◆ 第4章 服务治理与负载均衡

##### ◆ 4.1 什么是服务治理

>微服务架构中各微服务实例的一个重要能力就是可以快速上线或下线，从而让服务可以快速进行水平扩展，并保证服务的可用性。
>
>服务治理通过抽象将服务消费者和服务提供者进行隔离。消费者不需要知道具体服务提供者的真实物理地址就可以进行调用，也无须知道具体有多少个服务者可用；而服务提供者只需要将自己注册到服务治理服务器中就可以对外提供服务，也不需要知道具体是哪些服务调用了自己。另一方面，服务治理能够为微服务架构提升应用弹性，当其中的一个服务提供者实例不可用或者出现问题时，服务治理服务器可以发现这个有问题的服务实例，在调度服务消费者时可以绕开有问题的服务实例，从而将对应用的影响降低到最低。

>服务治理服务器（Eureka服务器）：服务注册中心，负责服务列表的注册、维护和查询等功能，也就是Eureka服务器。
>·服务注册代理（服务提供者）：服务注册代理可以理解为一个Eureka客户端，负责将微服务所提供的服务向Eureka服务器执行注册、续约和注销等操作，以使服务消费者可以发现并进行消费。**在服务注册时需要向服务治理服务器提供服务名称、宿主服务器IP地址、服务端口号、域名等主要数据。**
>·服务发现客户端（服务消费者）：也是一个Eureka客户端。它在启动时会默认从所服务治理服务器中获取所有的服务注册表信息，通过所获取到的服务注册列表信息来消费相应的服务。

>**在进行微服务构建时还需要遵守业务层级之间的划分，尽量避免微服务之间的循环依赖。**

##### ◆ 4.2 构建服务治理——Eureka

>@EnableEurekaServer注解，Spring Boot在启动应用的时候就会自动构建一个默认的服务治理服务器。
>
>@EnableDiscovery Client注解表示这是一个Eureka客户端，通过该注解，在Spring Boot启动完毕之后，就会根据配置中的信息尝试与服务治理服务器进行连接，连接成功之后进行服务注册或者服务注册信息的同步。

>如果一个服务实例单纯地仅作为服务提供者并不消费其他服务，那么就可以将eureka.client.fetch-registry设置为false。同样，如果一个服务实例仅作为服务消费者而不对外提供服务，那么可以将eureka.client.register-with-eureka设置为false。

>**一个服务实例注册到Eureka服务器时大概需要30秒才能够在控制台中查看到该服务**。这是因为，Eureka要求服务提供者必须发送3次心跳（默认每次心跳间隔为10秒）后才认为该服务实例已经准备好，可以对外提供服务了。因此，当启动完一个服务实例时，在Eureka控制台中没有立即显示是一种正常现象。

>Eureka服务器还提供了一个端点（/eureka/apps/[APPID]）可以查看所注册的服务详细信息

>对于每一个需要注册到Eureka服务器的服务都需要提供以下两个ID。
>·application.name：即应用的ID，用来对服务进行分组，相同的ID表示这些服务实例所提供的服务是相同的。
>
>instanceId：也就是微服务实例ID，用来标识每一个注册到Eureka服务器中的服务实例。默认情况下该值是由：服务宿主机器名称+服务名称+端口号构成，

>对于微服务架构来说，在编写代码时最好能够遵守自治的原则，所以这里UserDto类需要在商品微服务中编写，而不是依赖用户微服务中的相关代码。采用这种方式还有一个好处就是，让我们可以对用户对象进行裁剪，从而更适合商品微服务。

##### ◆ 4.3 使用客户端负载均衡——Ribbon

>集中式负载均衡（如F5）有以下缺点。
>**·单点失败：**单点失败却难以避免，一旦负载均衡宕机，则整个应用将无法访问。
>**·难扩展：**集中式负载均衡不是说不能够进行扩展，而是扩展时非常困难，往往需要人工介入，这在微服务架构所要求快速启停服务时很难做到。
>**·复杂：**运维人员往往需要经过培训、摸索，才能使用，并配备专业技术人员或者向厂家购买维护服务才可以。

>根据负载均衡所在位置的不同，目前针对微服务架构中负载均衡的解决方案主要有以下3种。
>
>**第一种解决方案是集中式负载均衡方案。**在服务消费者和服务提供者之间有一个独立的负载均衡系统来承担负载均衡功能，这种方案和之前的传统单体架构负载均衡实现原理一致。
>
>![image-20200422081059098](C:\Users\MrLi\AppData\Roaming\Typora\typora-user-images\image-20200422081059098.png)
>
>**第二种解决方案是进程内负载均衡方案**。该方案将负载均衡处理功能以库的方式整合到服务消费者应用中，因此该方案**也被称为客户端负载均衡方案**。这个解决方案需要配合服务发现功能，在服务消费者启动时需要从服务发现服务器中获取所有服务注册信息，并定时同步这些注册信息。当服务消费者需要访问某个服务时，内置的负载均衡器就会以某种负载均衡策略选择一个目标服务实例，然后在本地所缓存的服务注册表信息中查询该目标服务的具体地址，最后向目标服务发起请求。
>
>![image-20200422081046839](C:\Users\MrLi\AppData\Roaming\Typora\typora-user-images\image-20200422081046839.png)
>
>**第三种解决方案是：主机独立负载均衡进程方案**。该方案是针对第二种解决方案的一种折中处理方案，原理和第二种方案基本类似，所不同之处是将负载均衡和服务发现功能从服务消费者的进程内移出来，变成同一个主机上的一个独立进程，为该主机上的一个或者多个服务消费者提供负载均衡处理
>
>![image-20200422081028083](C:\Users\MrLi\AppData\Roaming\Typora\typora-user-images\image-20200422081028083.png)

###### ribbon实现原理

>（1）Ribbon首先根据其所在Zone优先选择一个负载较少的Eureka服务器。
>（2）定期从Eureka服务器更新，并过滤服务实例列表。
>（3）根据指定的负载均衡策略，从可用的服务实例列表中选择一个。
>（4）然后使用该地址，通过客户端进行服务调用。
>
>默认情况下，客户端负载均衡采用了轮询策略（RoundRobinRule）

##### ◆ 4.4 使用Feign简化微服务调用

>当我们通过RestTemplate调用其他微服务的API时，所需的参数必须在请求的URL中进行拼接

>Feign整合了Ribbon和Hystrix，可以让我们不再需要显式地使用这两个组件

>Feign具有如下特性：
>·可插拔的注解支持，包括Feign注解和JAX-RS注解。
>·支持可插拔的HTTP编码器和解码器。
>·支持Hystrix和它的回退功能。
>·支持Ribbon的负载均衡。
>·支持HTTP请求和响应的压缩处理。

>应用启动时Feign就会使用动态代码机制根据我们所定义的用户服务接口生成相应的类实例，并注入到Spring的应用上下文中。

>如果feiClient标注的类和主应用类不在同一个包中，那么在使用@EnableFeignClients注解时需要指定basePackages属性值。否则，当应用启动时就会报无法找到Bean的错误。

##### ◆ 4.5 深入Eureka

>在分布式系统领域有个CAP定理（CAP theorem），又被称为布鲁尔定理（Brewer'stheorem），它指出对于一个分布式计算系统来说，不可能同时满足以下3点。
>·一致性（Consistency）：同一个数据在集群中的所有节点，同一时刻是否都是同样的值。
>·可用性（Availability）：集群中一部分节点故障后，集群整体是否还能处理客户端的请求。
>·分区容忍性（Partition tolerance）：是否允许数据的分区，数据分区的意思是指是否允许集群中的节点之间无法通信。

>Zookeeper采用的设计原则就是CP原则，即任何时刻对Zookeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务请求的可用性。

>对于服务发现而言，可用性比数据一致性更加重要，AP胜过CP

>在Eureka的实现中，节点之间是相互平等的，部分注册中心的节点“挂掉”也不会对集群造成影响，即使集群中只剩一个节点存活，也可以正常提供发现服务。即使所有的服务注册节点都“挂”了，Eureka客户端中所缓存的服务实例列表信息，也能够让服务消费者正常工作，这就保证了微服务之间的互相调用是足够健壮的，微服务系统是具有足够弹性的。

###### 1．服务注册（Register）

>在微服务架构中，一个服务提供者本质上也是一个Eureka客户端。启动时，会调用Eureka所提供的服务注册相关方法，向Eureka服务器注册自己的信息。同时，在Eureka服务器会维护一个已注册的服务列表。注册服务列表使用一个嵌套HashMap保存信息，数据结构如下：
>·HashMap的第一层为应用名称和对应的服务实例。
>·HashMap的第二层为服务实例及其对应的注册信息，包括宿主服务IP地址、服务端口、运行状况指示符、URL等数据。
>
>当服务实例状态发生变化时（如微服务自身检测认为服务不可用的时候），就会向Eureka服务器更新自己的服务状态，同时用replicateToPeers()向其他Eureka服务器节点做状态同步。但是，当我们在服务配置文件中将eureka.client.register-with-eureka属性配置为false时，则不会执行上述的处理。

###### 2．服务续约（Renew）

>当服务启动并成功注册到Eureka服务器后，Eureka客户端会默认以每隔30秒的频率向Eureka服务器发送一次心跳（可以在配置文件中通过eureka.instance.lease-renewal-interval-in-seconds属性进行更改）。发送心跳起始就是执行服务续约（Renew）操作，避免自己的注册信息被Eureka服务器剔除。续约的处理逻辑和与服务注册逻辑基本一致：首先更新自身状态，然后同步到其他Eureka服务器节点。
>
>对于Eureka服务器来说如果在默认的时间内（90秒），也就是连续3次没有收到客户端的心跳，则会将该服务实例从所维护的服务注册表中剔除，以禁止流向该实例的流量
>
>如果该值设置得太大，即使服务实例已经不存在，也可能会有流量路由到该服务实例，造成服务调用失败。而如果设置太小，很可能因为网络问题导致服务实例误被Eureka服务器从服务注册表中剔除。因此，Eureka官方建议我们最好不要修改这两个属性的配置。

###### 3．服务下线与剔除

>当服务实例关闭时，服务实例会先向Eureka服务器发送服务下线请求。发送请求后，该服务实例信息将从Eureka服务器的实例注册表中删除。

###### 4．获取服务

>Eureka客户端在启动时会从Eureka服务器中获取注册表信息，并将其缓存在本地。Eureka客户端会使用该信息查找相应的服务，并进行调用。该注册列表信息定期（默认为30秒）从Eureka服务器进行同步。每次返回注册列表信息可能与Eureka客户端的缓存信息不同，由Eureka客户端自动处理。
>
>如果由于某种原因导致注册列表信息不能及时匹配，Eureka客户端则会重新获取整个注册表信息。
>
>在默认的情况下Eureka客户端使用压缩JSON格式来获取注册列表的信息。

###### 5．Region、Zone

> 这是云服务器可用地域、区域的概念

###### Eureka自我保护模式

>在自我保护模式下，Eureka服务器会保护服务注册表中的信息，不再注销任何服务实例

>**Eureka服务器自我保护模式开启的条件是：**
>
>当Eureka服务器每分钟收到心跳续租的数量低于一个阈值，就会触发自我保护模式。当它收到的心跳数重新恢复到阈值以上时，该Eureka服务器节点才会自动退出自我保护模式。心跳阀值计算公式如下：
>服务实例总数量×（60/每个实例心跳间隔秒数）×自我保护系数（0.85）
>
>此外，默认情况下Eureka服务器还会以每5分钟的间隔从与它对等的节点（这些节点由eureka.client.service-url.defaultZone配置指定）中复制所有的服务注册数据以达到同步的目的，如果这个同步因为某种原因导致失败，也会让Eureka服务器进入自我保护状态。
>可以通过eureka.server.wait-time-in-ms-when-sync-empty属性配置来设置这个时间间隔，或者直接禁用自我保护模式。

###### 4.5.3 注册一个服务实例需要的时间

>·Eureka服务器对服务注册列表进行缓存，默认时间为30秒。所以即使一个服务实例刚刚注册成功，它也可能不会立即在/eureka/apps端点的结果中出现。
>
>·Eureka客户端（服务消费方）对注册的服务信息进行缓存，默认时间为30秒，也就是说客户端决定刷新本地缓存并发现其他新注册的实例可能需要30秒。
>
>·Ribbon负载均衡会从Eureka客户端获取服务列表，并将负载均衡后的结果缓存30秒，所以对于Eureka客户端新同步过来的服务节点，可能也会需要30秒之后才能被负载均衡使用。
>
>·服务实例（Eureka客户端）在启动时（不是启动完成），不是立即向Eureka服务器注册，而是在一个延迟时间（默认为40秒）之后才向Eureka服务器注册。
>
>综上几个因素，一个新的服务实例，即使能够很快启动的实例，也不能马上被Eureka服务器发现，其他服务消费者需要一段时间，最长可能需要2分钟以上，才能够被发现和使用。

###### ◆ 4.6 深入Ribbon

>**客户端负载均衡实现方案核心3部分：**
>·服务发现：能够自动发现所依赖服务的列表。
>·服务监听：能够监测到失效的服务，并高效地将失效服务从服务列表中剔除。
>·服务选择策略：也就是负载均衡策略，能够决定如何在多个服务实例中选择一个有效的服务实例，并进行相应的服务请求处理。
>
>**Ribbon提供了的6个组件：**
>**1．服务器列表（ServerList）**
>服务器列表就是客户端负载均衡所使用的各服务的服务实例列表。Ribbon在实现上支持下面3种服务器列表方式。
>
>> ·静态服务器列表：可以通过Ribbon中的BaseLoadBalancer所提供的setServersList()方法直接进行设置。
>> ·基于配置的服务器列表：需要在项目配置文件中通过<服务名称>.ribbon.listOf Servers属性进行设置。
>>
>> ```
>> userService.ribbon.listOfSersers=http://192.168.0.0:2100,http://192.168.0.0:2101
>> ```
>>
>> ·基于服务发现的服务器列表：当我们在应用中同时使用Ribbon和Eureka时，默认就会使用该种方式，在应用启动时Ribbon就会从Eureka服务器中获取所有注册服务的列表数据，并保持同步。
>
>**2．服务器列表过滤器（ServerListFilter）**
>当开发者使用动态服务器列表时，该组件会对原始服务列表使用一定策略进行过滤，并返回有效的服务器列表给客户端负载均衡器使用。Ribbon在具体实现上提供以下可用过滤器供开发者在应用中进行选择。
>
>> ·ZoneAffinityServerListFilter：该过滤器基于区域感知的方式，实现对服务实例过滤，仅返回与本身所处区域一致的服务提供者实例列表。
>> ·ServerListSubsetFilter：该过滤器继承自ZoneAffinityServerListFilter，在进行区域感知过滤后，仅返回一个固定大小的服务列表，也就是说不会返回全部符合条件的服务实例列表。这种过滤器非常适用于拥有大规模服务器集群的系统。默认将返回20个服务实例，但可以通过ribbon.ServerListSubsetFilter.size属性设置具体返回的服务实例个数。·ZonePreferenceServerListFilter：是Spring Cloud整合Netflix时新增的一个过滤器。当开发者使用Spring Cloud整合Eureka和Ribbon时就会默认使用该过滤器。其主要是实现通过配置或者Eureka所属区域来过滤出同区域的服务实例列表。
>
>**3．服务实例存活探测（IPing）**
>简单来说服务实例存活探测就像开发者常用的ping指令一样，用来监测一个微服务实例是否有响应。Ribbon通过该组件来判断所持有的服务实例列表中的各服务可用情况，如果监测到某服务实例不再可用则会从列表中及时剔除。
>
>> Ribbon默认提供的实现如下。
>> ·PingUrl：通过定期访问指定的URL，来判断服务器是否可用。
>> ·PingConstant：不做任何处理，只是返回一个固定值，用来表示该服务器是否可用，默认值为true，即可用。
>> ·NoOpPing：不做任何处理，直接返回true，表示该服务器可用，这是默认策略。
>> ·DummyPing：直接返回true，但实现了initWithNiwsConfig方法。
>> ·NIWSDiscoveryPing：根据DiscoveryEnabledServer中InstanceInfo的InstanceStatus属性判断，如果该属性的值为InstanceStatus.UP，则表示服务器可用，否则为不可用。
>
>**4．负载均衡策略（IRule）**
>负载均衡策略是负责选择一个最终服务实例地址作为负载均衡处理结果。Ribbon提供的选择策略有轮询、根据响应时间加权、断路器（当Hystrix可用时）等。
>
>**5．负载均衡器（ILoadBalancer**）
>Ribbon负载均衡的具体实现主要是通过LoadBalancerClient类来实现的，而LoadBalanCer又将具体处理委托给ILoadBalancer来处理。对于ILoadBalancer，可以理解为客户端负载均衡“大总管”，其通过配置IRule、IPing等信息，并通过ServerList获取服务器注册列表的信息，默认以每10秒的频率向服务列表中的每一个服务实例发送ping请求，检测服务实例是否仍存活，最后使用负载均衡策略对ServerListFilter过滤得到最终可用的服务实例列表进行处理，并获取到最终要调用的服务实例，然后就可以交给服务调用器进行调用。
>
>**6．服务调用器（RestClient**）
>服务调用器也就是负载均衡后，Ribbon向服务提供者发起REST请求的工具。

>那么为何当我们在RestTemplate增加@LoadBalance注解后就可以为服务调用开启负载均衡处理呢？
>这就是LoadBalancerInterceptor的功劳了。当给RestTemplate增加了@LoadBalance注解后，LoadBalancerAutoConfiguration就会对该RestTemplate进行处理，在RestTemplate的拦截器列表中添加一个LoadBalancerInterceptor拦截器，当通过RestTemplate进行服务请求时，LoadBalancerInterceptor中的拦截方法就会启动，通过LoadBalancerClient使请求具有负载均衡功能，

>**ribbon负载均衡策略**
>
>负载均衡策略主要负责从可用服务实例列表中选择一个，作为最终所要访问的服务实例
>
>RoundRobinRule：轮询策略，Ribbon以轮询的方式选择服务实例，即每次调度执行i = (count + 1) mod n，并选出第i台服务实例。其中count为执行请求的计数次数， n为当前可用的服务器总个数。这个是默认值，所以示例中所启动的两个用户服务会被商品服务交替访问到。
>·RandomRule：随机选择，也就是说Ribbon会随机从可用的服务实例列表中选择一个进行访问。·BestAvailableRule：最大可用策略，即先过滤出故障服务实例后，选择一个当前并发请求数最小的。·WeightedResponseTimeRule：带有加权的轮询策略，对各个服务实例响应时间进行加权处理，然后再采用轮询的方式获取相应的服务实例。
>·AvailabilityFilteringRule：可用过滤策略，先过滤出有故障的或并发请求大于阈值的一部分服务实例，然后再以线性轮询的方式从过滤后的实例清单中选出一个实例。
>·ZoneAvoidanceRule：区域感知策略，先使用主过滤条件（区域负载器，选择最优区域）对所有实例过滤并返回过滤后的实例清单，依次使用次过滤条件列表中的过滤条件对主过滤条件的结果进行过滤，判断最小过滤数（默认1）和最小过滤百分比（默认0），最后对满足条件的服务实例则使用RoundRobinRule（轮询方式）方式选择一个，这个策略可以降低服务之间的调用延迟，提升系统效率。

>**注意**：再用代码配置负载均衡策略时，需要在配置类上增加@Configuration注解，但是不能让@Component Scan扫描到，否则该配置类中所构建的Bean将会覆盖Spring上下文，也就是说会覆盖Ribbon默认的配置，这样不但UserService服务使用该配置，所有的Ribbon客户端也会使用该配置，但这可能不是我们想要的。那么如何不被@Component Scan扫描到呢？有两种实现方式：一种是在@ComponentScan注解中显式声明排出，另外一种是让这些配置不在应用引导类所在包的下面。

###### ◆ 4.7 深入Feign

>SpringCloud还对Feign进行了增强，使得Feign支持了Spring MVC注解：
>·@RequestParam：绑定单个请求参数值。
>·@PathVariable：绑定URI模板变量值。
>·@RequestHeader：绑定请求头数据。
>·@RequestBody：绑定请求的内容区数据并能进行自动类型转换等。

>**注意：**
>
>1. 在feign中使用@RequestParam、@PathVariable等spring MVC注解，它们的value都是不可以少的，也就是说不能像Spring MVC Controller中这样声明：
>
>```
>@RequestMapping(value = "/products/{itemCode}", method = RequestMethod.GET)        
>Product loadByItemCode(@PathVariable String itemCode);
>```
>
>因为，在Spring MVC中这些注解会以参数名称作为默认值，但Feign则不会，必须声明。
>
>> 这个自己在实践中也发现了，而且如果直接写参数（没有使用spring MVC注解说明)，feign默认请求为post，
>
>2. feiqi请求的对象必须要有默认构造函数，否则Feign会无法根据传递过来的JSON字符串转换为User对象，从而抛出异常，造成调用不成功。
>
>3. 不推荐、也不建议在服务提供方和服务消费方之间共享接口。
>
>   > 比如endpoint 直接继承feign服务接口
>   > 在使用微服务架构进行开发时有一个原则，就是保持各微服务的自治性。假如像上面这样通过继承的方式，会造成服务提供方与服务消费方之间代码的紧耦合，一方修改代码都会对另一方造成干扰

###### ◆ 4.8 微服务健康监控

>Spring已经提供了一个Spring Actuator子项目，该子项目开箱即用。Actuator提供的对应用系统自身和监控的集成功能，包含了对应用系统进行配置查看、运行状态监控及相关功能统计等功能
>
>·/autoconfig：该端点用来获取Spring Boot自动化配置机制所产生的自动化配置信息报告，包含了所有自动化配置的候选项及每个候选项自动化配置条件是否满足等信息。
>·/beans：该端点列出所有由Spring Boot创建Bean的配置列表。
>·/configprops：该端点用来获取应用中配置的属性信息报告。
>·/env：该端点用来获取应用所有可用的环境属性报告，包括环境变量、JVM属性、应用的配置、命令行中的参数等。
>·/health：该端点用来报告当前应用的健康状态报告信息，比如应用是否启动、磁盘空间等。
>·/metrics：该端点用来报告当前应用及宿主主机的各类重要度量指标，比如CPU数量、内存信息、线程信息和垃圾回收信息等。
>·/mappings：在应用使用了Spring MVC时，该端点返回所有控制器映射关系报告。
>·/info：该端点用来返回应用自定义属性配置信息。
>·/shutdown：通过该端点可以关闭应用。
>
>```properties
># 禁用/shutdown端点        
>endpoints.shutdown.enabled=false        
># 禁用/configprops端点        
>endpoints.configprops.enabled=false
>```
>
>

###### ◆ 4.9 异构服务解决方案——Sidecar

>通过Sidecar，可以将异构的服务加入Spring Cloud所构建的服务架构体系中。

#### ◆ 第5章 微服务容错保护——Hystrix

##### ◆ 5.1 什么是微服务容错保护

>**Hystrix解决的问题：**
>
>·对第三方接口/依赖服务潜在的调用失败提供保护和控制机制。
>·在分布式系统中隔离资源，降低耦合，防止服务之间相互调用而导致级连失败；
>·快速失败及迅速恢复。
>·在合适的时机对服务进行优雅降级处理。
>·对服务提供近乎实时的监控、报警和控制操作。
>
>在请求失败频率较低的情况下，Hystrix还会直接把故障返回给客户端。只有当失败次数达到阈值（默认在20秒内失败5次）时，断路器才会被打开并且不再进行后续通信，从而直接进行服务降级（fallback）处理。
>
>Hystrix的开发和实现遵守如下设计理念：
>
>·防止由于单个服务的故障，而耗尽整个系统容器（如Tomcat）的线程资源。
>·快速失败，而不是在队列中积压服务请求。
>·提供服务降级（fallback）处理机制。
>·使用隔离技术（如舱壁隔离、泳道和断路器等模式）来隔离服务依赖之间的影响。
>·通过近乎实时的监控和告警，及时发现系统中的潜在问题。
>·通过配置更改可以优化低延迟传播的恢复时间，并且Hystrix支持大多数属性的动态更改，从而允许开发者可以实时对低延迟反馈循环进行修改和优化。
>·提供对整个所依赖客户端在执行过程中的故障保护与隔离，而不仅仅是网络流量。
>
>Hystrix是想通过隔离保护和自我调节机制而提供强大的容错能力，避免任何一个第三方依赖或服务调用的单点故障而带来级联失败的问题，从而避免整个服务崩溃。

##### ◆ 5.2 快速启动Hystrix

>**对于微服务容错来说保护的是服务消费方**
>
>Hystrix使用：引入Hystrix依赖、 开启Hystrix支持
>
>@EnableCircuit Breaker注解告诉Spring微服务需要在项目中使用Netflix的Hystrix库，通过该库开启对服务的容错保护。
>
>实现服务的保护需要使用@HystrixCommand注解，该注解告诉服务调用者在调用失败时可以通过fallbackMethod参数指定的方法来实现服务降级处理。

>5.2.5 服务降级的两种实现方式：
>
>1．使用@HystrixCommand注解完成服务降级实现
>
>注意：通过fallbackMethod所指定的方法要与原方法具有相同的方法签名，否则会降级失败。
>
>> @HystrixCommand注解的属性说明如下。
>> ·groupKey：设定HystrixCommand分组的名称。
>> ·commandKey：设定HystrixCommand的名称。
>> ·threadPoolKey：设定HystrixCommand执行线程池的名称。
>> ·fallbackMethod：设定HystrixCommand服务降级所使用的方法名称，注意该方法需要与主方法定义在同一个类中，并且方法签名也要一致。
>> ·commandProperties：设定HystrixCommand属性，比如，断路器失败百分比、断路器时间窗口大小等，具体属性可以参考后面的讲解。
>> ·threadPoolProperties：设定HystrixCommand所执行线程池的属性，比如，线程池的大小、线程池等待队列长度等。
>> ·ignoreExceptions：设定HystrixCommand执行服务降级处理时需要忽略的异常，也就是当出现这些异常时不会执行服务降级处理。
>> ·observableExecutionMode：设定HystrixCommand执行的方式。
>> ·defaultFallback：设定HystrixCommand默认的服务降级处理方法，如同时设定了fallbackMethod，会优先使用fallbackMethod所指定的方法。这里还需要说明的一点是该属性所指定的方法没有参数，所以需要注意以下返回值与主方法返回值的兼容性。
>
>2．继承HystrixCommand完成服务降级实现

>> HystrixCommand和HystrixObservableCommand，其中后者是用在所依赖服务返回多个操作结果的时候。在实现服务降级时，如果是继承HystrixCommand，则需要实现getFallback()方法，如果是继承HystrixObservableCommand，则需要实现resumeWithFallback()方法。

##### ◆ 5.3 Hystrix容错机制分析

>·Hystix通过HystrixCommand或HystrixObservableCommand对所有第三方依赖/服务调用进行封装，整个封装对象是运行在一个单独线程之中。
>·可配置依赖调用超时时间，超时时间一般设为比99.5%平均时间略高即可。当调用超时时，直接返回或进行服务降级处理。
>·为每个依赖关系/服务调用维护一个小的线程池（或信号量），如果已满，那么依赖服务调用将立即被拒绝，而不是排队等待。
>·对服务调用的执行状态：成功、失败（客户端抛出异常）、超时及线程拒绝等进行统计；
>·如果某服务调用的错误百分比高于阈值，则可以通过手动或自动的方式打开断路器，这样在一段时间内停止对该服务调用的所有请求。
>·当服务请求被拒绝、连接超时或者断路器打开时，可以直接执行服务降级处理（fallback）；
>·Hystrix提供几乎实时的指标监控和配置变化。
>
>![image-20200426225226724](C:\Users\MrLi\AppData\Roaming\Typora\typora-user-images\image-20200426225226724.png)

从上图可以看出，以下几种情况都会进入服务降级处理：

>·断路器已打开；
>·无资源执行命令(线程池、队列或信号量已满)；
>·执行命令失败；
>·执行命令超时。

>在实现服务降级处理时，最好能够提供一个默认的处理结果，该结果最好是从内存缓存中或者一个静态逻辑处理中计算得到，不要再有任何网络调用的依赖。这是因为，一旦降级处理中包含网络处理，那么势必需要再次对该响应进行HystrixCommand/HystrixObservableCommand封装处理，从而造成级联处理，增大了系统的不稳定性，并且，降级处理终究还是要回归到一个能够稳定返回的实现上。

>HystrixCommand和HystrixObservableCommand两个类有什么区别呢？
>
>从命令模式上来说，HystrixCommand是一个阻塞型命令，当执行命令时可以直接获取到执行结果。而HystrixObservableCommand是一个非阻塞型命令，该命令的调用者通过订阅其返回对象来获取执行的结果。不过，HystrixCommand命令也提供了observe()方法，可以返回一个非阻塞型对象，但返回的Observable对象只能向调用者发送一次数据。
>·从代码编写上来说，HystrixCommand命令的业务逻辑写在run()方法中，服务降级逻辑写在getFallback()方法中；而HystrixObservableCommand的业务逻辑写在construct()方法中，服务降级逻辑写在resumeWithFallback()方法中。
>·从执行上来说，HystrixCommand的run()是由新创建的线程执行；而HystrixObservableCommand的construct()则是由调用程序线程执行。
>·从执行返回的结果来说，HystrixCommand只能返回一个执行结果；而HystrixObservableCommand则可以按顺序向调用者发送多条执行结果。

execute()、queue()、observe()和toObservable()4种命令执行方式之间的关系、区别

>区别
>
>> ·execute()：该方法将以同步堵塞方式执行run()。也就是说当调用execute()后，Hystrix将会首先创建一个新线程来运行run()，同时调用者程序会在execute()调用处一直处于堵塞状态，直到run()运行完成。
>> ·queue()：该方法将以异步非堵塞方式执行run()。也就是说当调用queue()后，调用者线程就直接返回一个Future对象，同时Hystrix创建一个新线程运行run()，调用者通过Future.get()拿到run()的返回结果，而Future.get()则是堵塞执行的。
>> ·observe()：执行该方法时，Hystrix会首先触发执行HystrixCommand的run()方法，或执行HystrixObservableCommand的construct()方法。对于HystrixCommand，将创建一个新线程以非堵塞方式执行run()；如果是HystrixObservableCommand，将在调用程序线程堵塞执行construct()。然后再调用subscribe()完成事件注册，如果run()或construct()执行成功则触发onNext()和onCompleted()方法，如果执行异常则触发onError()。
>> ·toObservable()：与observe()不同的是，toObservable()方法是先注册，注册完成后自动触发并执行run()或construct()方法。
>
>联系
>
>> 从源码中可以看到：execute()方法其实是通过queue().get()方法实现的；而queue()方法是通过toObservable().toBlocking().toFuture()方法实现的；observe()方法是通过toObservable().subscribe(subject)方法实现的。所以说，最终每一种调用方式都是基于toObservable()这个方法实现的。

 断路器原理分析

>Hystrix在运行过程中会向每个命令对应的断路器报告成功、失败、超时和拒绝的状态，断路器维护计算统计的数据，根据这些统计的信息来确定断路器是否打开。如果打开，后续的请求都会进行服务降级处理。然后会隔一段时间尝试半开，放入一部分流量请求进来，相当于对依赖服务进行一次健康检查，如果恢复，那么断路器会关闭，随后完全恢复调用。

断路器如何打开

>·当在一个滚动统计窗口中命令请求数超过requestVolumeThreshold设置的值（默认值为20）时。
>·命令执行失败百分比超过了errorThresholdPercentage设置的值（默认值为50%）。
>也就是在默认情况下错误率超过50%且10秒内超过20个命令请求进行中断拦截，这时候断路器将会被打开，Hystrix将会对所有命令执行请求进行服务降级处理。

Hystrix异常——HystrixBadRequestException

>在HystrixCommand的run()方法中，如果运行时抛出了异常，就会执行降级处理，但是有一个异常例外，即HystrixBadRequestException。当run()方法抛出该异常后，Hystrix并不会触发服务降级处理逻辑，所以当开发者需要在命令执行过程中抛出不需要进行降级处理的异常时，就可以抛出该异常。

##### ◆ 5.4 服务隔离

>Hystrix的核心是提供服务容错保护，并且其设计原则中就有一条：**防止任何单一依赖使用掉整个容器（如Tomcat）的全部用户线程**。那么Hystrix是如何实现的呢？答案是舱壁隔离模式（Bulkhead Isolation Pattern）。

>Hystrix实现服务隔离的思路如下：
>
>使用命令模式（HystrixCommand/HystrixObservableCommand）对服务调用进行封装，使每个命令在单独线程中/信号授权下执行。
>·为每一个命令的执行提供一个小的线程池/信号量，当线程池/信号已满时，立即拒绝执行该命令，直接转入服务降级处理。
>·为每一个命令的执行提供超时处理，当调用超时时，直接转入服务降级处理。
>·提供断路器组件，通过设置相关配置及实时的命令执行数据统计，完成服务健康数据分析，使得在命令执行过程中可以快速判断是否可以执行，还是执行服务降级处理。

>**服务隔离策略**
>
>Hystrix提供了线程池隔离（Thread Pools）和信号量隔离（Semaphores）两种服务隔离策略。
>·线程池隔离：不同服务的执行使用不同的线程池，同时将用户请求的线程（如Tomcat）与具体业务执行的线程分开，业务执行的线程池可以控制在指定的大小范围内，从而使业务之间不受影响，达到隔离的效果。
>·信号量隔离：用户请求线程和业务执行线程是同一线程，通过设置信号量的大小限制用户请求对业务的并发访问量，从而达到限流的保护效果。

>Hystrix拥有专门的线程池可提供内置的并发功能，可以在同步调用之上构建异步外观模式，这样能很方便地做异步编程（Hystrix引入了Rxjava异步框架）

>**服务隔离颗粒度控制策略：**
>·服务分组+线程池：实现服务隔离的粗粒度控制，一个服务分组/系统配置一个隔离线程池即可。也可以不配置线程池名称或者配置为相同的线程池名称。
>·服务分组+服务+线程池：实现服务隔离的细粒度控制，一个服务分组中的每一个服务配置一个隔离线程池，为不同的命令实现配置不同的线程池名称即可。
>·混合实现：一个服务分组配置一个隔离线程池，然后对重要服务单独设置隔离线程池。

>服务隔离配置
>
>·execution.isolation.strategy：设定服务隔离策略。THREAD为线程池隔离，SEMAPHORE为信号量隔离。默认值为THREAD。
>execution.isolation.thread.timeoutInMilliseconds：用来设置线程池隔离和信号量隔离两种隔离策略的超时时间，单位为毫秒，默认值是1000ms.。一般设置为比业务平均响应时间大20%~100%即可。execution.isolation.semaphore.maxConcurrentRequests：该值设置使用信号量隔离时最大的信号量大小。当请求达到或超过该设置值后，其余就会被降级处理，默认值是10。
>execution.timeout.enabled：是否开启业务服务超时处理，默认值是true。·execution.isolation.thread.interruptOnTimeout：当业务服务超时时是否中断线程，默认值是true。·execution.isolation.thread.interruptOnCancel：取消时是否中断业务服务的执行，默认值是false。

>**隔离策略选择**
>
>线程池隔离把执行业务服务线程与用户请求线程分离，请求线程可以自由控制离开的时间（异步过程）。通过线程池大小可以控制并发量，当线程池饱和时可以提前拒绝服务，防止依赖问题扩散。建议线程池不要设置过大，否则大量堵塞线程有可能会拖慢服务器。
>
>**当请求的服务网络开销比较大的时候，或者请求比较耗时的时候，最好使用线程隔离策略**。这样，可以保证用户请求（如Tomcat）线程可用，不会由于业务服务原因，使用户请求一直处于阻塞或等待状态，而是快速失败返回。
>
>**当我们请求缓存服务或者不涉及远程RPC调用（没有网络开销）服务的时候，应优先使用信号量隔离策略**，因为这类服务通常会快速返回，不会占用容器线程太长时间，同时也减少了线程切换的一些开销，提高了服务效率。

##### ◆ 5.5 服务降级模式

>**快速失败模式**是指在服务降级处理逻辑中不提供任何处理，直接抛出一个异常。
>
>**静默失败**即当进行服务降级处理时返回空的结果，针对返回值类型，返回的可能是null、空List或者空Map等。
>
>**返回默认值**，服务降级时返回静态的在代码中固定的值。
>
>**返回组装的值**：cookies；·服务请求的参数及Header；·之前成功返回的结果中。
>
>**返回远程缓存**是指在服务处理失败的情况下再发起一次远程请求，不过这次请求的是一个缓存，比如读取Redis中的缓存结果。
>
>> 当使用远程缓存时，需要注意的是获取远程缓存又是一个远程调用，所以需要重新封装为Command进行调用。这时候要注意，执行fallback的线程一定要与主线程区分开，否则可能会造成主线程休眠，线程池被耗光，也就是说在执行fallback的命令时需要重新命名ThreadPoolKey。
>
>**主/从降级模式**:有时候开发者在部署新功能时，为了防止发生错误，可以将原来的旧代码作为从模式，当新功能出现错误时就降级使用原功能。
>
>> 如果从模式仅仅是用来作为主服务失败时的辅助处理，那么最好的方式是将主模式和从模式使用门面模式（façade）重新构建一个新的命令，而不是使用主/从模式。
>>
>> 由于主/从命令都是采用线程池隔离方式执行的，那么所构建的门面命令则可以使用信号量隔离方式，避免了系统多余的开销。

##### ◆ 5.6 请求缓存

>Hystrix还提供了下面3个缓存注解来简化开发:
>·@CacheResult：标记返回结果需要进行缓存，该注解要与@HystrixCommand注解一起使用。·@CacheKey：用来标记如果构建缓存的值，其功能类似于getCacheKey()方法。
>·@CacheRemove：用来标记在方法执行完毕后清除指定的缓存。

##### ◆ 5.7 请求合并

>Hystrix支持将多个请求自动合并为一个请求.
>
>需要注意的是，多个请求能自动合并的前提是请求之间要足够“近”，即执行的间隔时长要足够小（默认为10ms，可通过hystrix.collapser.default.timerDelayInMilliseconds进行设置），即执行间隔超过10ms的请求不会合并执行。
>
>请求合并实现方式：
>
>> ·对于请求合并的处理，需要实现上继承HystrixCollapser基类；
>> ·还需要实现一个批量请求的BatchCommand，该Command负责调用用户服务的批量查询方法；
>> ·然后再实现mapResponseToRequests()方法，将批量返回的结果映射到每个请求中。

##### ◆ 5.8 Hystrix监控

>开启Hystrix监控非常简单，一个是添加spring-cloud-starter-hystrix依赖，这个在之前的示例中已经添加；另一个是添加spring-boot-starter-actuator依赖，能够让hystrix-stream端点获取到Hystrix的监控数据。

>·实心圆：包含两个含义，颜色表示实例的健康程度，健康程度从绿色、黄色、橙色、红色递减；大小则根据请求流量的大小发生变化，流量越大则实心圆越大，反之则越小。
>·曲线：统计了2分钟内的请求流量的变化，通过该曲线可以对流量进行上升和下降的趋势分析。

>Hystrix Dashboard支持3种监控方式
>·默认集群监控
>·指定集群监控
>单机应用监控

>Turbine把相同的服务、不同的实例作为一个统一整体来看待，

#### ◆ 第6章 API服务网关——Zuul

>**当需要重复实现某一个功能时，就是好好思考架构设计的最佳时机。**
>
>spring cloud 一推出第二代网关 gateway

##### ◆ 6.1 API服务网关

>API服务网关的核心是：为所有客户端请求或其他消费者提供统一的网关，通过该网关接入不同的微服务，并隐藏架构实现的细节。

>对API服务网关总结如下：
>·API服务网关帮助开发者隐藏系统架构实现的细节，提供统一的入口供客户端访问，让微服务使用更为友好。
>·通过微服务的统一访问控制，简化了客户端开发的复杂度，降低了客户端与微服务之间的通信次数，客户端不需要与多个微服务之间进行通信，也不需要了解各个微服务的详细信息。
>·借助API服务网关可统一做切面任务，避免每个微服务自己开发，提升效率，使系统更加标准化。
>·通过API服务网关，可以将异构系统进行统一整合。
>·API服务网关需要实现一个高可用伸缩性强的服务，避免单点失效。
>·API服务网关需要对所有微服务实例所暴露的端点进行统一的管理，这为开发和运维增加了一定的难度。

##### ◆ 6.2 Spring Cloud与Netflix Zuul

>Netflix Zuul组件可以用于反向代理功能，通过路由寻址将请求转发到后端的服务上，并增加一些通用逻辑处理。Zuul对请求提供了路由和过滤器两个功能，其中，路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础。过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。
>
>通过Zuul组件，可以完成以下功能:
>
>> ·动态路由
>> ·监控与审查
>> 身份认证与安全
>> ·压力测试
>> ·金丝雀、A/B测试
>> ·服务迁移
>> ·负载剪裁/限流

##### ◆ 6.3 启用Zuul路由服务

>Spring Cloud提供的@EnableZuulProxy注解可以用来创建Zuul路由服务器，所创建的路由服务可以是嵌入式服务，也可以进行独立部署。

>只需要定义服务器使用的端口、服务名称及Eureka服务器的地址就可以了，

>Zuul路由服务器的默认设计就是能够与Spring Cloud相关产品进行整合，应用到这里就是Zuul将默认从Eureka服务器中获取所注册的服务，然后将服务的ID作为请求路径中的一部分，然后将用户的请求自动转发到这些服务中。

>对于IP地址及端口号的分配也非常重要，越早规范越能够避免后续的运维压力

>开发者在构建API访问网关的时候需要把握以下两个原则：KISS原则和stateless原则。
>
>> KISS原则是指Keep it Simple and Stupid，也就是说要保持API服务网关的简单和轻量。服务网关只不过是服务调用过程中的一个检查点，不应该用来处理业务的复杂性，也不应将其用于解决架构的难点上，这些应该是微服务需要处理的事情。
>>
>> stateless原则是指在Zuul服务网关中不应该、也不可以保存有关服务调用过程中的状态数据

>可以看到Zuul本身已经默认集成了Hystrix和Ribbon，所以Zuul天生就拥有线程隔离和服务容错的自我保护能力，以及对服务调用的客户端负载均衡功能.
>
>当使用path与url的映射关系来配置路由规则时，对于路由转发的请求则不会采用Hystrix Command来包装，所以这类路由请求就没有线程隔离和服务容错保护功能，并且也不会有负载均衡的能力。因此在使用Zuul的时候尽量使用path和serviceId的组合进行配置，这样不仅可以保证API网关的健壮和稳定，也能用到Ribbon的客户端负载均衡功能。

##### ◆ 6.4 路由配置规则

Zuul提供了以下几种机制对请求路由进行映射：

> ·与Eureka服务器整合自动根据微服务的ID进行映射，这个是默认机制，也是之前示例中所使用的机制。
>
> > http://[zuul路由服务器地址]/[serviceId]/[具体服务的端点]
>
> ·结合微服务ID通过自定义方式进行路由映射。
>
> >配置为“/user/*”时只能匹配一级路径,而设置为“/user/**”则可以匹配所有以“/user/”开头的访问路径
>
> ·直接使用静态URL路径的方式对微服务进行路由映射。
> ·添加全局路由映射。
> ·通过自定义路由转换器，实现更灵活的路由映射。

>Zuul默认会将所有注册到Eureka服务器中的服务进行映射，假如你的微服务实例尚未注册到Eureka服务器中，如果通过routes端点来查看，是看不到相应路由映射的；但如果是通过自定义的方式进行路由映射配置，那么不论你的微服务是否已经注册到Eureka服务器中，routes端点都会返回该路由映射。

**忽略指定微服务**

>Zuul路由服务器配置中提供了一个属性zuul.ignored-services，通过设置该属性可以指定在默认映射中所要忽略的微服务，指定后Zuul的路由服务将不再代理该路径下的访问。
>
>如果想让Zuul忽略所有服务的路由映射，并全部采用自定义方式，那么只需要将zuul.ignored-services的值设置为“*”即可。

**设置路由前缀**

>Zuul提供了zuul.prefix属性可为所有的路由映射增加统一前缀。

>默认情况下，Zuul代理会在转发到具体服务实例时自动剥离这个前缀。如果需要在转发时带上该前缀，可以将zuul.stripPrefix属性的值设置为false来关闭这个默认行为。需要说明的是，zuul.stripPrefix只会对zuul.prefix的前缀起作用，而对于path指定的前缀不会起作用。

**路由配置顺序**

>如果在配置时需要按照配置的顺序进行路由规则控制，则需要使用yaml格式的配置文件，如果是使用properties文件格式，则会丢失配置顺序。

##### ◆ 6.5 Zuul路由其他设置

>Spring Cloud Config子项目提供了配置文件的统一管理，我们需要将原来存放在src/main/resources目录下的配置文件application.properties或yml文件抽出来统一存放在版本管理服务器上，比如Git中，然后将Zuul路由服务器的配置从统一配置服务器中进行加载

##### ◆ 6.7 Zuul过滤器

>Zuul其实包含了两个功能：路由和过滤器。路由的功能是负责将外部请求转发到具体的微服务实例上，过滤器的功能则是负责对请求的处理过程进行干预，是实现请求校验

>在运行时，动态地将切面代码切入到类的指定位置，这些位置则称为切入点。这样在不改变原来代码的基础上完成代码行为的改造，避免了这些共同功能对业务代码功能的侵入

从源码中可以看到Zuul过滤器的关键特性有以下几点:

>·Type：定义在请求执行过程中何时被执行；
>·Execution Order：当存在多个过滤器时，用来指示执行的顺序，值越小就越早执行；
>·Criteria：执行的条件，即该过滤器何时被触发；
>·Action：该过滤器具体要执行的动作。

**过滤器类型**

>·PRE过滤器：在请求被路由之前调用，可用来实现身份验证、在集群中选择请求的微服务、记录调试信息等。
>
>·ROUTING过滤器：在调用目标服务之前被调用，通常可以用来处理一些动态路由。比如，A/B测试
>
>·POST过滤器：在目标微服务执行以后，所返回的结果在送回给客户端时被调用
>
>·ERROR过滤器：该过滤器在处理请求过程中发生错误时被调用，可以使用该过滤器实现对异常、错误的统一处理

**zuul过滤器生命周期**

>（1）对于任何注册到Zuul服务网关中的PRE过滤器，在请求被路由之前，该类型的过滤器可以对请求进行监控或修改，但是不可以将服务请求重新定位到不同的服务中。
>
>（2）当Zuul执行了PRE类型的过滤器之后，服务请求就会被转发到ROUTING过滤器中执行，而ROUTING类型的过滤器执行时可以将服务请求根据需要分发到不同的服务实例中执行。这个也是之前所讲到的，可以利用ROUTING过滤器实现A/B测试等功能。但需要注意的是，虽然ROUTING类型的过滤器可以改变Zuul配置中所要分发到的服务实例，但是不能执行HTTP的重定位。
>
>（3）根据ROUTING过滤器处理的结果执行具体的服务处理，如果ROUTING过滤器改写了所要执行的服务，那么将会按照ROUTING过滤器的结果调用相应的服务进行处理，否则Zuul服务网关将调起默认的服务实例。
>
>（4）当目标服务执行后，Zuul服务网关将转回执行所注册的POST过滤器，在该过滤器中，我们对返回给客户端的结果进行最后的处理，也可以增加通用的一些用户行为采集、审计日志等功能。
>
>（5）一旦在整个处理过程中出现了错误，那么就会转入ERROR过滤器中执行，在这里可以对异常、错误进行统一处理，并返回更加友好的信息给客户端调用者。

##### ◆ 6.8 @EnableZuulServer与@EnableZuulProxy比较

>简单来说@Enable ZuulProxy注解包含@EnableZuulServer的所有功能，并且还加入了@EnableCircuitBreaker和@EnableDiscoveryClient

#### ◆ 第7章 统一配置中心——Config

**微服务的配置管理需要处理以下数据**：

>·在微服务架构中配置数据与服务实例不要在同一个地方，最好各自独立分开。当微服务部署时也不应该包含这些配置数据，而是当微服务启动时从一个集中的配置源中进行读取。
>
>·解决非侵入式配置数据的织入。在每个微服务中不希望通过硬编码的方式从某个配置文件、原程仓库或者数据中读取配置数据，而是最好通过一种更通用的方式让微服务可以快速加载这些配置资源。
>
>配置文件的管理最好是集中式的。通过对配置文件的集中式管理，可以非常方便地对微服务的配置进行统一修改和发布，并能够建立版本机制，以便后续进行配置数据的回溯。
>
>保障配置服务的高可用性

##### ◆ 7.1 Spring Cloud Config简介

>Spring Cloud Config具有中心化、版本控制、支持动态更新和语言独立等特性
>
>Spring Cloud Config有两个角色（类似Eureka）: Server和Client。
>
>Server作为配置中心的服务端承担如下作用：
>
>> ·当配置客户端获取配置时，服务端及时从Git仓库中获取配置副本，从而保证配置数据为最新。
>> ·支持从yml、json、properties等文件加载配置；
>> ·配合Eureke可实现服务发现，配合Cloud Bus（后面会详细介绍）可实现配置推送更新。
>> ·默认配置存储基于Git仓库（可以切换为SVN），从而支持配置的版本管理。
>
>对于Client，即各个微服务，使用则非常方便，只需要在引导配置文件（bootstrap.properties或bootstrap.yml）中声明所使用的配置服务器地址即可。

##### ◆ 7.2 快速启动

>Spring Boot应用在启动时会根据bootstrap.properties配置文件创建一个引导上下文（Bootstrap Context）的文件，引导上下文将负责从外部加载配置属性并进行相应的解析，并作为Spring应用上下文（Application Context）的父上下文。此外，这两个上下文将共享一个从外部获取的Environment。默认情况，引导上下文的配置属性具有高优先级，不会被本地配置覆盖

>当我们启动ProductService微服务时，Spring Cloud Config相关代码将根据bootstrap.properties所配置的服务名称和所要启动的profile向配置服务器的端点请求配置数据。配置服务器在收到配置数据请求后，根据相应的参数，从配置资源库（文件系统、Git或者SVN仓库，示例中是Git仓库）加载相应的配置文件，然后根据这些配置文件来构建数据，并将这些数据回传给配置客户端，最后Spring Boot应用框架将根据所获得的配置数据来构建应用上下文，并启动相应的应用。

###### 7.2.7 Spring配置加载顺序

>·命令行参数：命令行参数使用--xxx=xxx格式在启动时传递，比如：--server.port=2300，就是将服务的端口设置为2300。这里的参考可以是Spring Boot框架的参数，也可以是我们自定义的参数或属性配置。
>
>·从java:comp/env加载的JNDI属性。
>
>·Java系统属性：通过-Dxxx=xxx格式设置，只是优先级比上面的配置低。
>
>·操作系统环境变量：这里需要注意的一点是，有些操作系统配置时不支持使用点“.”进行分割，则需要将点替换成下画线。例如，server.port需要替换成server_port。
>
>·RandomValuePropertySource：使用random.*属性进行配置，主要是在系统配置中需要使用随机数的地方使用，如foo.securityid=${random.value}。
>
>·特定应用的properties或yml配置文件：这些文件名称的命名格式为application-{profile}.properties或者yml，通过指定所要使用的profile来加载，例如前面使用的application-dev.properties配置文件。
>
>·应用配置文件application.properties或yml文件：为Spring Boot应用所默认加载的配置文件，可以通过上面的配置进行全部或部分配置属性的覆写。
>
>·@Configuration、@PropertySource或@ConfigurationProperties所指向的配置文件，其中@ConfigurationProperties可以批量按照一定规范将配置注入到一个Bean中，但这些配置的优先级较低。

##### ◆ 7.3 配置资源库

>**配置客户端从配置服务器获取配置数据的整个流程**
>
>![image-20200428080327638](C:\Users\MrLi\AppData\Roaming\Typora\typora-user-images\image-20200428080327638.png)

>（1）当配置客户端启动时，根据bootstrap.properties中配置的应用名称（spring.application.name）、环境名（spring.profiles.active），向配置服务器请求获取配置数据。
>（2）配置服务器根据客户端的请求参数，以及配置文件中所配置的标签（spring.cloud.config.label，如果没有配置，对于Git来说默认为master分支），从Git仓库中按照上述规则去查找符合的配置文件。
>（3）配置服务器将匹配到的Git仓库拉取到本地，并建立本地缓存。
>（4）配置服务器根据所拉取到的配置文件创建Spring的ApplicationContext实例，然后将该配置信息返回给客户端。
>（5）客户端获取到配置服务器返回的数据后，将这些配置数据加载到自己的上下文中。同时，因为这些配置数据的优先级高于本地JAR包中的配置，因此将不再加载本地的配置。
>
>label则是对应的Git上分支名称，是一个可选参数，如果没有，则默认从master分支进行查找。
>
>注意：如果Git的分支或标签中包含“/”时，在{label}参数中需要使用“_”替代，这是为了避免与HTTP URL转义符处理时的冲突。

配置服务器从Git仓库中获取配置信息后，将会在本地的文件系统中存储一份。

为了避免出现这种不可预知的错误，最好还是为配置服务器指定明确的本地缓存路径

>在配置服务器的配置文件中添加spring.profiles.active=native配置属性，就可以开启对文件系统的支持。

>Spring Cloud官方推荐在测试和开发的时候可以使用文件系统，但是在正式环境中还是尽量使用Git或者SVN。

##### ◆ 7.4 配置的加密与解密

>Spring Cloud Config提供了两种加解密方式：对称加密和非对称加密

>建议就是将密码存放在配置服务器的系统环境变量中。另外，千万不要忘记所设置的密码，一旦忘记该密码，将无法对已加密的内容进行解密与恢复，还有一点就是不要把数据库密码设置得太简单了。

>Keytool是一个Java数据证书的管理工具，Keytool使用keystore文件存储密钥和证书

##### 7.5 配置服务器访问安全

> 使用Spring Security来做访问安全控
>
> ```
> security.user.name= 11
> security.user.password=sss
> ```
>
> 注意：如果不配置用户名和密码的话，在配置服务器启动时，Spring Security会默认生成一个访问密码。

##### ◆ 7.6 配置服务器的高可用

>整合eureka
>
>可以通过设置clone-on-start，让配置服务器在启动时就加载配置文件。一方面在启动时就执行加载可以及时告知运维人员配置仓库是否可用；另一方面当客户端第一次发起请求时可以立即返回配置数据。
>
>动态刷新配置:增加对spring-boot-starter-actuator的依赖

#### 第8章 分布式服务跟踪——Sleuth

##### ◆ 8.1 Spring Cloud Sleuth简介

##### 8.2 Sleuth与ELK整合

##### ◆ 8.3 整合Zipkin服务

>**Zipkin主要涉及以下4个组件:**
>
>·collector：数据采集组件，用来收集Sleuth所生成的跟踪数据。
>
>·storage：数据存储组件，将采集的数据进行存储以便后续进行分析。
>
>·search：数据查询组件，对采集到的数据处理后，就可以通过查询组件进行过滤、分析等处理。
>
>·UI：数据展示组件。

##### ◆ 8.4 Sleuth抽样采集与采样率

>采样器并不会阻碍Span相关ID的产生及相应追踪数据的采集，但是会对导出及附加事件标签的相关操作造成影响。一旦采样器将Span中的exportable值设置为false时，Sleuth将不会把这个追踪数据推送给Zipkin服务器，但还是能够在日志中看到这些数据。

#### 第9章 消息驱动——Stream

##### ◆ 9.1 什么是消息驱动开发

>**基于消息中间件开发的优点**
>
>1．降低应用耦合
>
>2．改善应用性能
>
>3．提升应用的可扩展性
>
>3．提升应用的可扩展性
>
>4．提高系统的可用性
>
>5．更灵活的系统集成

>缺点：1．更复杂的应用架构。2.基于消息的开发模式对开发、调试、运维来说都是一个非常大的挑战。3．更陡峭的学习曲线

##### 9.2 Spring Cloud Stream简介

Spring Cloud Stream进行消息的发送和消费时涉及下面4个概念。

> 1．消息发送通道接口Source
>
> 2．消息通道Channel
>
> 3．消息绑定器Binder
>
> 4．消息监听通道接口Sink

##### ◆ 9.5 Spring Cloud Stream高级主题

>TestSupportBinder来支持单元测试，可以让开发者在没有连接到消息中间件的情况下完成测试

>在创建应用时，最好为其指定一个消费者组，这样可以防止当启动多个应用实例时收到重复的消息

#### ◆ 第10章 微服务应用安全——Security

>对于业务应用安全，主要考虑两方面：一方面是保障只有认证的用户才可以访问应用，也就是用户认证；另一方面就是要保障访问者只有拥有足够的权限才可以访问某个资源，也就是用户鉴权。

##### ◆ 10.2 微服务安全

>**微服务架构下的安全4种解决方案:**
>
>1．单点登录（SSO）方案:需要每个与用户交互的服务都必须与认证服务进行通信，这不但会造成重复，也会产生大量琐碎的网络流量
>
>2．分布式会话（Session）方案:使用redis，方案在高可用和扩展方面都很好，但是由于会话信息保存在共享存储中，所以需要一定的保护机制保护数据安全，因此在具体的实现中会具有比较高的复杂度。
>
>3．客户端令牌（Token）方案：令牌由客户端生成，并由认证服务器签名。在令牌中会包含足够的信息，客户端在请求时会将令牌附加在请求上，从而为各个微服务提供用户身份数据。
>
>4．客户端令牌与API网关结合：通过在微服务架构中实施API网关，可以将原始的客户端令牌转换为内部会话令牌。一方面可以有效地隐藏微服务，另一方面通过API网关的统一入口可以实现令牌的注销处理。

##### ◆ 10.3 基于OAuth 2.0的认证

>###### 10.3.1 OAuth 2.0授权流程
>
>![image-20200428083128134](C:\Users\MrLi\AppData\Roaming\Typora\typora-user-images\image-20200428083128134.png)

>在OAuth 2.0中定义了4种客户端授权模式，分别是授权码模式（Authorization Code）、简化模式（Implicit）、密码模式（Resource Owner Password Credentials）和客户端模式（ClientCredentials）

##### ◆ 10.4 基于JWT的认证

>JWT是基于JSON的一个开放标准-RFC7519，其代表的是一种紧凑的、URL安全的、能够在网络应用间传输的声明

>客户端与资源服务器及认证服务器之间的交互流程如下：
>
>（1）客户端调用认证服务器的登录接口/获取Token接口，传入用户名密码。
>（2）认证服务器确认用户名密码，并创建JWT返回给客户端；
>（3）客户端获取到JWT后进行缓存。
>（4）客户端请求资源服务器，并在请求的HTTP头部中附加JWT。
>（5）资源服务端对JWT进行校验，校验通过后，向客户端返回相关的资源和数据。
>
>![image-20200428083251636](C:\Users\MrLi\AppData\Roaming\Typora\typora-user-images\image-20200428083251636.png)

>**在搭建微服务架构的应用时安全方案可以首先考虑JWT方案。**

### 第3篇 微服务与Docker容器技术

#### 第11章 微服务与Docker

##### ◆ 11.1 Docker简介

>Docker是目前最流行的Linux容器解决方案。Docker可以很方便地将软件与所需要依赖的库或组件打包整合到一个镜像文件里，然后运行这个镜像，就生成了一个虚拟容器。同时，配置好的镜像文件可以很容易地通过Docker的接口进行备份导出，上传到仓库，从而达到复用的目的，而不需要每台计算机都重新配置一遍。

##### ◆ 11.2 Docker的使用

>查看Docker所支持的所有命令

>在Docker中有3个重要的概念：仓库、镜像和容器。

>Docker仓库就是用于存放镜像的地方

>容器是基于镜像运行的虚拟实例，类似前面所提到的虚拟机，但又与虚拟机有所区别。
